我还没有来得及测试，但是他们使用了互斥和子进程的方式做通信控制


https://blog.csdn.net/mybelief321/article/details/9170041?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control

基础实验1

 功能

   本实验意在说明如何使用基本的共享内存函数。首先创建一个共享内存区（采用的共享内存的键值是IPC_PRIVATE，是因为本实验中创建的共享内存是父子进程间的共用部分），然后创建子进程，在父子两个进程中将共享内存分别映射到各自的进程地址空间中。

    父进程先等待用户输入，然后将用户输入的字符串写入到共享内存，之后向共享内存的头部写入“WROTE”字符串表示父进程已成功写入数据。子进程一直等到共享内存的头部字符串为“WROTE”，然后将共享内存的有效数据（在父进程中用户输入的字符串）在屏幕上打印。父子两个进程在完成以上工作后，分别解除与共享内存的映射关系。

    最后在子进程中删除共享内存。因为共享内存自身并不提供同步机制，所以应额外实现不同进程间的同步（如信号量）。为了简单起见，在本实验中用标志字符串来实现非常简单的父子进程间的同步。

    在本实验中，用到了一个命令是 ipcs ，它用于报告进程间通信机制状态，它可以查看共享内存、消息队列等各种进程间通信机制的情况，这里使用了system()函数调用shell命令"ipcs -m"，有关于ipcs命令和system()函数不了解的可以查查哈。

源程序

   程序上传到网站，如有需要，请自行下载，shmem.c文件




   基础实验2

功能

   完成的功能和基础实验1一样，唯一不同的就是实现同步的方法不一样，实验1是利用标志字符位来实现同步的，而本实验是利用信号量实现同步的，如果信号量不会的话，请看博客：

 http://blog.csdn.net/mybelief321/article/details/9086151

源程序

   本程序中有关信号量的代码我是直接复制上一节的代码，本实验的完整程序我上传到网站，如有需要请自行下载，shmem_sem.c文件